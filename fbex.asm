; beware -- nasty assembler code of poor quality lies ahead
; portions (c) autogenerated by GCC compiler

global _start

; tty ioctls
%define KDSETMODE 0x00004B3A

; tty ioctl args
%define KD_TEXT 0x00000000
%define KD_GRAPHICS 0x00000001

; fb ioctls
%define FBIOGET_VSCREENINFO 0x00004600
%define FBIOPUT_VSCREENINFO 0x00004601
%define FBIOGET_FSCREENINFO 0x00004602

; open(2) flags
%define O_RDWR 0x00000002

; mmap(2) prot flags
%define PROT_READ 0x00000001
%define PROT_WRITE 0x00000002

; mmap(2) flags
%define MAP_SHARED 0x00000001

; syscalls
%define open   2 ; rdi = char * filename, rsi = int flags
%define mmap   9 ; rdi = ulong addr, rsi = ulong len, rdx = ulong prot, r10 = ulong flags
                 ;                                    r8 = ulong fd, r9 = ulong offset
%define ioctl 16 ; rdi = uint fd, rsi = uint cmd, rdx = uint arg 
%define sleep 35 ; rdi = timespec, rsi = 0
%define exit  60 ; rdi = int error_code
%define rdlnk 89 ; rdi = char * path, rsi = char * buf, rdx = int buf_sz

section .data
        fb_path: db '/dev/fb0', 0
        stdout_fd_path: db '/proc/self/fd/0', 0

        timeval:
                tv_sec: dq 0
                tv_usec: dq 0

        fb_map: dq 0

        double_one: dq 1.0
        double_neg_one: dq -1.0

section .bss
        %define tty_buf_sz 255
        tty_path: resb tty_buf_sz

        finfo: resb 80 ; struct fb_fix_screeninfo
        %define finfo_line_length 48    ; dword

        vinfo: resb 160 ; struct fb_var_screeninfo
        %define vinfo_grayscale 28      ; dword
        %define vinfo_bpp 24            ; dword
        %define vinfo_xres_virtual 8    ; dword
        %define vinfo_yres_virtual 12   ; dword
        %define vinfo_xres 0            ; dword
        %define vinfo_yres 4            ; dword
        %define vinfo_xoffset 16        ; dword
        %define vinfo_yoffset 20        ; dword

section .text
; flush screen
; 'fb_map', 'finfo' and 'vinfo' must be initialized
flush:
        mov rdi, [fb_map]
        mov rax, 0
        mov eax, dword [vinfo + vinfo_yres_virtual]
        mul dword [finfo + finfo_line_length]
        mov rdx, 0
        fill_loop:
                mov dword [rdi + rdx], 0x00000000
                add rdx, 4      ; next pixel, 32 bits per pixel
                cmp rdx, rax
                jb fill_loop
        ret

; draw a dot
; 'fb_map' and 'vinfo' must be initialized
; rdi = color
; rsi = x coord
; rdx = y coord
dot:
        ; save y coord in r8 because rdx is overwritten by mul
        mov r8, rdx

        mov rcx, [fb_map]
        mov rax, 4
        mul rsi
        add rcx, rax
        mov rax, 0
        mov eax, dword [finfo + finfo_line_length]
        mul r8
        mov dword [rcx + rax], edi
        ret

; check if dot is blank (= black)
; does not modify arguments!
; 'fb_map' and 'vinfo' must be initialized
; rsi = x coord
; rdx = y coord
; @return rax = zero if dot was blank, non-zero otherwise
blank:
        ; save y coord in r8 because rdx is overwritten by mul
        mov r8, rdx

        mov rcx, [fb_map]
        mov rax, 4
        mul rsi
        add rcx, rax
        mov rax, 0
        mov eax, dword [finfo + finfo_line_length]
        mul r8

        mov rdx, r8

        mov r9d, dword [rcx + rax]
        cmp r9d, 0
        jne blank_not_ret

        mov rax, 0
        ret

        blank_not_ret:
            mov rax, 1
            ret

; fill black areas
; 'vinfo' must be initialized
; rdi = color
; rsi = begin x coord
; rdx = begin y coord
fill:
        push r15
        push r14
        push r13
        push r12

        mov r12, 1
        push rsi
        push rdx

        fill_loop_:
            cmp r12, 0
            je fill_ret

            mov r15, rdi
            mov rdx, [rsp]
            mov rsi, [rsp + 8]

            call blank
            cmp rax, 0
            jne fill_pop

            call dot
            mov rax, 0

            fill_pop:
                pop rdx
                pop rsi
                dec r12
                cmp rax, 0
                jne fill_loop_

            fill_add_right:
                add rsi, 1
                cmp esi, dword [vinfo + vinfo_xres]
                jge fill_add_left
                call blank
                cmp rax, 0
                jne fill_add_left
                push rsi
                push rdx
                inc r12

            fill_add_left:
                sub rsi, 2
                cmp rsi, 0
                jl fill_add_bottom
                call blank
                cmp rax, 0
                jne fill_add_bottom
                push rsi
                push rdx
                inc r12

            fill_add_bottom:
                add rsi, 1
                add rdx, 1
                cmp edx, dword [vinfo + vinfo_yres]
                jge fill_add_top
                call blank
                cmp rax, 0
                jne fill_add_top
                push rsi
                push rdx
                inc r12

            fill_add_top:
                sub rdx, 2
                cmp rdx, 0
                jl fill_loop_
                call blank
                cmp rax, 0
                jne fill_loop_
                push rsi
                push rdx
                inc r12

            jmp fill_loop_

        fill_ret:
            pop r12
            pop r13
            pop r14
            pop r15
            ret

; calculate tangent based on two points
; rdi = x1 coord
; rsi = y1 coord
; rdx = x2 coord
; rcx = y2 coord
; @return xmm0 = tan
tan:
        sub rcx, rsi
        pxor xmm0, xmm0
        cvtsi2sd xmm0, rcx
        sub rdx, rdi
        pxor xmm1, xmm1
        cvtsi2sd xmm1, rdx
        divsd xmm0, xmm1
        ret

; sleep for 40 mseconds (25 fps)
; uses 'timeval' struct
sleep40m:
        mov qword [tv_sec], 0
        mov qword [tv_usec], 40000
        mov rdi, timeval
        mov rsi, 0
        mov rax, sleep
        syscall
        ret

; draw a line between two points
; rdi = color
; rsi = x1 coord
; rdx = y1 coord
; rcx = x2 coord
; r8  = y2 coord
line:
        ; save registers
        push r15
        push r14
        push r13
        push r12
        push rbp
        push rbx

        ; reserve 8 bytes on stack for tangent
        sub rsp, 0x8

        ; save args
        mov r12, rdi
        mov r13, rsi
        mov r15, rdx
        mov rbx, rcx
        mov rbp, r8

        ; reorder args for calculating tangent
        mov rcx, r8
        mov rdx, rbx
        mov rsi, r15
        mov rdi, r13
        call tan

        ; save tangent on stack
        movsd qword [rsp], xmm0

        ; check if line is vertical or horizontal
        ; by comparing tan with 1.0
        comisd xmm0, [double_one]
        jbe horizontal_line

        vertical_line:
            ; check if line is of negative length
            cmp r15, rbp
            je line_ret
            jg vertical_flag_neg

            ; line direction flag is set on stack
            push qword 1
            jmp vertical_loop_init

            vertical_flag_neg:
                push qword -1

            vertical_loop_init:
                mov r14, r15
                add rbp, [rsp]
                sub rbp, r15
                mov ebx, 0x0

                ; invert tangent
                movsd xmm0, [double_one]
                divsd xmm0, [rsp + 8]
                movsd [rsp + 8], xmm0

            vertical_loop_body:
                lea rdx, [rbx+r14]
                pxor xmm0, xmm0
                cvtsi2sd xmm0, rbx
                mulsd xmm0, [rsp + 8]
                cvttsd2si rsi, xmm0
                add rsi, r13
                mov rdi, r12
                call dot
                call sleep40m
                add rbx, qword [rsp]
                cmp rbp, rbx
                jne vertical_loop_body

            ; release line direction flag
            add rsp, 8

        line_ret:
            ; release reserved stack bytes
            add rsp, 8

            ; restore registers
            pop rbx
            pop rbp
            pop r12
            pop r13
            pop r14
            pop r15
            ret

        horizontal_line:
            ; ... and with -1.0
            comisd xmm0, [double_neg_one]
            jb vertical_line

            ; check if line is of negative length
            cmp r13, rbx
            je line_ret
            jg horizontal_flag_neg

            ; line direction flag is set on stack
            push qword 1
            jmp horizontal_loop_init

            horizontal_flag_neg:
                push qword -1

            horizontal_loop_init:
                mov rbp, r13
                add rbx, [rsp]
                sub rbx, r13
                mov r13, rbx
                mov ebx, 0x0

            horizontal_loop_body:
                pxor xmm0, xmm0
                cvtsi2sd xmm0, rbx
                mulsd xmm0, [rsp + 8]
                cvttsd2si rdx, xmm0
                add rdx, r15
                lea rsi, [rbx + rbp]
                mov rdi, r12
                call dot
                call sleep40m
                add rbx, qword [rsp]
                cmp rbx, r13
                jne horizontal_loop_body

            ; release line direction flag
            add rsp, 8

            jmp line_ret

; draw a circle
; rdi = color
; rsi = center x coord
; rdx = center y coord
; rcx = radius
circle:
        test rcx, rcx
        jle circle_ret

        push r15
        push r14
        push r13
        push r12
        push rbp
        push rbx

        mov r14, rdi
        mov r15, rsi
        mov r13, rdx
        mov rbp, rcx
        mov r12d, 0x0
        mov ebx, 0x0
        jmp circle_loop_body

        circle_loop_cond:
            cmp rbp, rbx
            jl circle_ret_full

        circle_loop_body:
            mov rdx, r13
            add rdx, rbp
            mov rsi, r15
            add rsi, rbx
            mov rdi,r14
            call dot

            mov rdx, r13
            add rdx, rbp
            mov rsi, r15
            sub rsi, rbx
            mov rdi,r14
            call dot

            mov rdx, r13
            sub rdx, rbp
            mov rsi, r15
            add rsi, rbx
            mov rdi,r14
            call dot

            mov rdx, r13
            sub rdx, rbp
            mov rsi, r15
            sub rsi, rbx
            mov rdi,r14
            call dot

            mov rsi, r15
            add rsi, rbp
            mov rdx, r13
            add rdx, rbx
            mov rdi,r14
            call dot

            mov rsi, r15
            add rsi, rbp
            mov rdx, r13
            sub rdx, rbx
            mov rdi,r14
            call dot

            mov rsi, r15
            sub rsi, rbp
            mov rdx, r13
            add rdx, rbx
            mov rdi,r14
            call dot

            mov rsi, r15
            sub rsi, rbp
            mov rdx, r13
            sub rdx, rbx
            mov rdi,r14
            call dot

            add rbx,0x1
            add r12,rbx
            mov rax, rbp
            sar rax, 1
            cmp r12, rax
            jl circle_loop_cond
            sub rbp,0x1
            sub r12,rbp
            jmp circle_loop_cond

        circle_ret_full:
            pop rbx
            pop rbp
            pop r12
            pop r13
            pop r14
            pop r15

        circle_ret:
            ret

; sleep for 5 seconds
; uses 'timeval' struct
sleep5:
        mov qword [tv_sec], 5
        mov qword [tv_usec], 0
        mov rdi, timeval
        mov rsi, 0
        mov rax, sleep
        syscall
        ret

_start:
        mov rdi, stdout_fd_path ; get current tty path from stdout fd
        mov rsi, tty_path
        mov rdx, tty_buf_sz
        mov rax, rdlnk
        syscall
        cmp rax, 0
        jl close

        mov rdi, tty_path       ; open tty fd
        mov rsi, O_RDWR
        mov rax, open
        syscall
        cmp rax, 0
        jl close

        mov r12, rax            ; save tty fd to restore its mode later

        mov rdi, rax            ; set tty mode to graphics
        mov rsi, KDSETMODE
        mov rdx, KD_GRAPHICS
        mov rax, ioctl
        syscall
        cmp rax, 0
        jl close

        mov rdi, fb_path        ; open framebuffer fd
        mov rsi, O_RDWR
        mov rax, open
        syscall
        cmp rax, 0
        jl rollback_tty

        mov r13, rax            ; save framebuffer fd

        mov rdi, rax            ; load framebuffer fixed parameters
        mov rsi, FBIOGET_FSCREENINFO
        mov rdx, finfo
        mov rax, ioctl
        syscall
        cmp rax, 0
        jl rollback_tty

        mov rdi, r13            ; load framebuffer variable parameters
        mov rsi, FBIOGET_VSCREENINFO
        mov rdx, vinfo
        mov rax, ioctl
        syscall
        cmp rax, 0
        jl rollback_tty

                                ; update framebuffer variable parameters
                                ; set color mode with 32 bits per pixel
        mov dword [vinfo + vinfo_grayscale], 0
        mov dword [vinfo + vinfo_bpp], 32
        mov rdi, r13
        mov rsi, FBIOPUT_VSCREENINFO
        mov rdx, vinfo
        mov rax, ioctl
        syscall
        cmp rax, 0
        jl rollback_tty

        mov rdi, 0              ; map framebuffer to memory
        mov rax, 0
        mov eax, dword [vinfo + vinfo_yres_virtual]
        mul dword [finfo + finfo_line_length]
        mov rsi, rax
        mov rdx, PROT_READ | PROT_WRITE
        mov r10, MAP_SHARED
        mov r8, r13
        mov r9, 0
        mov rax, mmap
        syscall
        cmp rax, 0
        jl rollback_tty
        mov [fb_map], rax

        ; task #2 -- dot at (x: 64, y: 1), color: #5555FF
        call flush
        mov rdi, 0x005555FF
        mov rsi, 64
        mov rdx, 1
        call dot
        call sleep5

        ; task #3 -- dot at (x: 303, y: 150), color: #55FF55
        call flush
        mov rdi, 0x0055FF55
        mov rsi, 303
        mov rdx, 150
        call dot
        call sleep5

        ; task #4 -- horizontal line
        call flush
        mov rdi, 0x005555FF
        mov rsi, 0
        mov edx, dword [vinfo + vinfo_yres]
        sar rdx, 1
        mov ecx, dword [vinfo + vinfo_xres]
        mov r8, rdx
        call line
        call sleep5

        ; task #5 -- vertical line
        call flush
        mov rdi, 0x005555FF
        mov esi, dword [vinfo + vinfo_xres]
        sar rsi, 1
        mov rdx, 0
        mov rcx, rsi
        mov r8d, dword [vinfo + vinfo_yres]
        call line
        call sleep5

        ; task #6 -- circle w/ fill
        call flush
        mov rdi, 0x005555FF
        mov esi, dword [vinfo + vinfo_xres]
        sar rsi, 1
        mov edx, dword [vinfo + vinfo_yres]
        sar rdx, 1
        mov rcx, 50
        call circle
        mov rdi, 0x00FFFFFF
        mov rsi, 475
        mov rdx, 0
        mov ecx, dword [vinfo + vinfo_xres]
        shr rcx, 2
        add rcx, 135
        mov r8d, dword [vinfo + vinfo_yres]
        call line
        mov rdi, 0x00222222
        mov esi, dword [vinfo + vinfo_xres]
        sar rsi, 1
        dec rsi
        mov edx, dword [vinfo + vinfo_yres]
        sar rdx, 1
        call fill
        call sleep5

        rollback_tty:           ; restore tty mode back to text
                mov rdi, r12    ; tty fd
                mov rsi, KDSETMODE
                mov rdx, KD_TEXT
                mov rax, ioctl
                syscall

        close:
                mov rdi, 0
                mov rax, exit
                syscall